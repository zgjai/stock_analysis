<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>测试编辑交易记录API修复</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" rel="stylesheet">
</head>
<body>
    <div class="container mt-4">
        <h2>测试编辑交易记录API修复</h2>
        
        <div class="alert alert-info">
            <h5>问题描述:</h5>
            <p>编辑交易记录时，API请求 <code>/api/trades/calculate-batch-profit</code> 返回400错误，导致页面一直显示加载状态</p>
            
            <h5>问题原因:</h5>
            <ul>
                <li>ProfitTargetsManager初始化时自动添加空的止盈目标</li>
                <li>空目标触发API调用，但数据无效导致400错误</li>
                <li>买入价格可能还没有设置就触发了计算</li>
            </ul>
            
            <h5>修复方案:</h5>
            <ul>
                <li>在 <code>validateAndPreviewBatchProfit</code> 中添加更严格的验证</li>
                <li>修改 <code>addTarget</code> 方法支持不触发通知的初始化</li>
                <li>确保只有有效数据才会触发API调用</li>
            </ul>
        </div>

        <div class="card">
            <div class="card-header">
                <h5>模拟测试场景</h5>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <h6>模拟买入价格输入</h6>
                        <input type="number" id="mock-price" class="form-control" placeholder="买入价格" step="0.01">
                    </div>
                    <div class="col-md-6">
                        <h6>模拟止盈目标</h6>
                        <div id="mock-targets">
                            <!-- 动态生成的止盈目标 -->
                        </div>
                    </div>
                </div>
                
                <div class="mt-3">
                    <button type="button" class="btn btn-primary" onclick="testValidCalculation()">
                        测试有效数据计算
                    </button>
                    <button type="button" class="btn btn-warning" onclick="testInvalidCalculation()">
                        测试无效数据处理
                    </button>
                    <button type="button" class="btn btn-info" onclick="testEmptyData()">
                        测试空数据处理
                    </button>
                    <button type="button" class="btn btn-success" onclick="testInitialization()">
                        测试初始化流程
                    </button>
                </div>
            </div>
        </div>

        <div class="mt-3">
            <h5>测试结果:</h5>
            <div id="test-results" class="alert alert-secondary">
                点击上面的按钮进行测试...
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // 模拟API客户端
        const mockApiClient = {
            async calculateBatchProfit(buyPrice, profitTargets) {
                console.log('API调用:', { buyPrice, profitTargets });
                
                // 模拟API验证逻辑
                if (!buyPrice || buyPrice <= 0) {
                    throw new Error('买入价格无效');
                }
                
                if (!profitTargets || profitTargets.length === 0) {
                    throw new Error('止盈目标列表不能为空');
                }
                
                // 检查目标数据格式
                for (let i = 0; i < profitTargets.length; i++) {
                    const target = profitTargets[i];
                    const targetPrice = parseFloat(target.targetPrice || target.target_price);
                    const sellRatio = parseFloat(target.sellRatio || target.sell_ratio);
                    
                    if (!targetPrice || targetPrice <= 0) {
                        throw new Error(`第${i+1}个止盈目标价格无效`);
                    }
                    
                    if (!sellRatio || sellRatio <= 0) {
                        throw new Error(`第${i+1}个止盈目标卖出比例无效`);
                    }
                }
                
                // 模拟成功响应
                return {
                    success: true,
                    data: {
                        totalExpectedProfit: 1000,
                        totalExpectedProfitRatio: 10.5,
                        targets: profitTargets.map((target, index) => ({
                            ...target,
                            expectedProfit: 200 * (index + 1),
                            expectedProfitRatio: 2.5 * (index + 1)
                        }))
                    }
                };
            }
        };

        // 模拟验证和预览函数（修复后的版本）
        async function mockValidateAndPreviewBatchProfit(buyPrice, profitTargets) {
            try {
                // 更严格的验证条件
                if (buyPrice <= 0) {
                    return { skipped: true, reason: '买入价格无效' };
                }

                if (!profitTargets || profitTargets.length === 0) {
                    return { skipped: true, reason: '没有止盈目标' };
                }

                // 检查是否有有效的止盈目标
                const validTargets = profitTargets.filter(target => {
                    const targetPrice = parseFloat(target.targetPrice || target.target_price);
                    const sellRatio = parseFloat(target.sellRatio || target.sell_ratio);
                    return targetPrice > 0 && sellRatio > 0;
                });

                if (validTargets.length === 0) {
                    return { skipped: true, reason: '没有有效的止盈目标' };
                }

                // 调用API计算预期收益
                const response = await mockApiClient.calculateBatchProfit(buyPrice, validTargets);
                
                return { success: true, data: response.data };
            } catch (error) {
                return { error: true, message: error.message };
            }
        }

        function testValidCalculation() {
            const results = document.getElementById('test-results');
            results.innerHTML = '测试有效数据计算...';
            
            const buyPrice = 10.50;
            const profitTargets = [
                { targetPrice: 11.00, sellRatio: 30 },
                { targetPrice: 11.50, sellRatio: 40 },
                { targetPrice: 12.00, sellRatio: 30 }
            ];
            
            mockValidateAndPreviewBatchProfit(buyPrice, profitTargets)
                .then(result => {
                    if (result.success) {
                        results.innerHTML = `<span class="text-success">✓ 有效数据计算成功</span><br>
                            <small>预期收益: ${result.data.totalExpectedProfit}, 收益率: ${result.data.totalExpectedProfitRatio}%</small>`;
                    } else {
                        results.innerHTML = `<span class="text-warning">⚠ 计算被跳过: ${result.reason || result.message}</span>`;
                    }
                })
                .catch(error => {
                    results.innerHTML = `<span class="text-danger">✗ 有效数据计算失败: ${error.message}</span>`;
                });
        }

        function testInvalidCalculation() {
            const results = document.getElementById('test-results');
            results.innerHTML = '测试无效数据处理...';
            
            const buyPrice = 10.50;
            const profitTargets = [
                { targetPrice: '', sellRatio: 30 }, // 无效的目标价格
                { targetPrice: 11.50, sellRatio: '' }, // 无效的卖出比例
            ];
            
            mockValidateAndPreviewBatchProfit(buyPrice, profitTargets)
                .then(result => {
                    if (result.skipped) {
                        results.innerHTML = `<span class="text-success">✓ 无效数据正确处理 - ${result.reason}</span>`;
                    } else if (result.error) {
                        results.innerHTML = `<span class="text-success">✓ 无效数据正确捕获错误 - ${result.message}</span>`;
                    } else {
                        results.innerHTML = `<span class="text-danger">✗ 无效数据未被正确处理</span>`;
                    }
                })
                .catch(error => {
                    results.innerHTML = `<span class="text-success">✓ 无效数据正确抛出异常: ${error.message}</span>`;
                });
        }

        function testEmptyData() {
            const results = document.getElementById('test-results');
            results.innerHTML = '测试空数据处理...';
            
            Promise.all([
                mockValidateAndPreviewBatchProfit(0, []), // 价格为0，空目标
                mockValidateAndPreviewBatchProfit(10.50, []), // 有价格，空目标
                mockValidateAndPreviewBatchProfit(0, [{ targetPrice: 11.00, sellRatio: 30 }]) // 价格为0，有目标
            ]).then(results_array => {
                const [result1, result2, result3] = results_array;
                
                let summary = '';
                if (result1.skipped) summary += '✓ 空价格空目标正确跳过<br>';
                if (result2.skipped) summary += '✓ 空目标正确跳过<br>';
                if (result3.skipped) summary += '✓ 空价格正确跳过<br>';
                
                results.innerHTML = `<span class="text-success">${summary}</span>`;
            });
        }

        function testInitialization() {
            const results = document.getElementById('test-results');
            results.innerHTML = '测试初始化流程...';
            
            // 模拟初始化时的空目标
            const emptyTarget = { targetPrice: '', sellRatio: '' };
            
            mockValidateAndPreviewBatchProfit(0, [emptyTarget])
                .then(result => {
                    if (result.skipped) {
                        results.innerHTML = `<span class="text-success">✓ 初始化时的空目标正确跳过 - ${result.reason}</span>`;
                    } else {
                        results.innerHTML = `<span class="text-danger">✗ 初始化时的空目标未被正确处理</span>`;
                    }
                });
        }

        // 自动运行测试
        setTimeout(() => {
            testInitialization();
        }, 1000);
    </script>
</body>
</html>